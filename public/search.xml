<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java模拟简单的CAS实现]]></title>
    <url>%2Fblog%2F2018%2F01%2F05%2Fjava-SimulatedCAS%2F</url>
    <content type="text"><![CDATA[这篇文章主要模拟CPU的CAS实现，详细的实现原理都加上注释了，不一一解释了。当然这不是真正的CAS实现，真正的CAS是CPU指令来实现的。 Compare And Swap(CAS)CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新为新的值。反之，会继续拿期望的值与原本的值作比较，知道成功为止。 模拟CAS实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.lang.reflect.Field;/** * 简单模拟CAS实现 * Created by Evai ON 1/3/18. */public class SimulatedCAS &#123; /** * 原始值 */ private long valueOffset; /** * 修改原始值 * @param o 需要修改的对象 * @param offset 需要修改的值 */ public void setValueOffset(Object o, long offset) &#123; setField(o, offset); &#125; /** * 获取原始值 * @return */ public long getValueOffset() &#123; return valueOffset; &#125; /** * 如果原始值和预期值相等，更新原始值及对象的value值，这里加了同步锁，模拟CAS原子操作 * @param o 需要修改的对象 * @param expect 预期值 * @param update 更新值 * @return */ public synchronized boolean compareAndSwap(Object o, long expect, long update) &#123; return getValueOffset() == expect &amp;&amp; setField(o, update); &#125; /** * 修改原始值及对象的value值 * @param o 需要修改的对象 * @param update 更新值 * @return */ private boolean setField(Object o, long update) &#123; long oldValue = getValueOffset();//存储旧的原始值 this.valueOffset = update;//更新为新值 try &#123; //获取对象上的value属性 Field field = o.getClass().getDeclaredField("value"); //设置该属性可访问权限 field.setAccessible(true); //旧值更新 field.set(o, update); return true; &#125; catch (Exception e) &#123; this.valueOffset = oldValue;//失败回滚原始值 throw new Error("更新值失败", e); &#125; &#125;&#125; 模拟AtomicLong实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 简单模拟AtomicLong实现 * Created by Evai ON 1/3/18. */public class AtomLong &#123; private static final SimulatedCAS cas = new SimulatedCAS(); private volatile long value; public AtomLong() &#123;&#125; public AtomLong(long v) &#123; //实例化类后更新value值及原始值 cas.setValueOffset(this, v); &#125; public long get() &#123; return value; &#125; /** * 类似 ++i * @return */ public long incrementAndGet() &#123; return getAndAddLong(1L) + 1L; &#125; /** * 类似 i++ * @return */ public long getAndIncrement() &#123; return getAndAddLong(1L); &#125; /** * 类似 --i * @return */ public long decrementAndGet() &#123; return getAndAddLong(-1L) - 1L; &#125; /** * 类似 i-- * @return */ public long getAndDecrement() &#123; return getAndAddLong(-1L); &#125; /** * 获取到当前value值（即期望值），如果期望值和原始值相等，返回value，反之继续获取最新的value值，循环直到相等为止 * @param delta 增减量 * @return */ private long getAndAddLong(long delta) &#123; long v; do &#123; v = get();//获取当前最新的value值 &#125; while (!cas.compareAndSwap(this, v, v + delta)); return v; &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132/** * Created by Evai ON 1/3/18. */public class CASCounter &#123; private static final AtomLong casLong = new AtomLong(1); private static final long LIMIT = 100; private static void incrementLong() &#123; try &#123; while (casLong.get() &lt; LIMIT) &#123; Thread.sleep(100); if (casLong.get() &lt; LIMIT) &#123; System.out.println(Thread.currentThread().getName() + ": " + casLong.getAndIncrement()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; incrementLong(); &#125; &#125;).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的AtomicLong类]]></title>
    <url>%2Fblog%2F2018%2F01%2F04%2Fjava-AtomicLong%2F</url>
    <content type="text"><![CDATA[由于Java的原子操作最多只支持32位的，而long和double是64位的，因此它们不具有原子性。 而在java中定义了AtomicLong这个类，来实现原子的long类型。那具体是怎么实现的？我们先来了解下CAS。 Compare And Swap(CAS)CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新为新的值，此处“原本的一个值”怎么来的，我们先看看AtomicLong类的几个实现： 12345678910//value值的偏移量private static final long valueOffset;//拿到value原来的值static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; 这里用到UnSafe类的一个方法objectFieldOffset()： 123456789101112131415161718/** * Report the location of a given static field, in conjunction with &#123;@link * #staticFieldBase&#125;. * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset; * it is just a cookie which is passed to the unsafe heap memory accessors. * * &lt;p&gt;Any given field will always have the same offset, and no two distinct * fields of the same class will ever have the same offset. * * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values, * although the Sun JVM does not use the most significant 32 bits. * It is hard to imagine a JVM technology which needs more than * a few bits to encode an offset within a non-array object, * However, for consistency with other methods in this class, * this method reports its result as a long value. * @see #getInt(Object, long) */public native long objectFieldOffset(Field f); 这个方法是用来拿到我们上文提到的“原本的一个值”的内存地址。是一个本地方法，返回值是valueOffset。它的参数field就是AtomicLong里定义的value属性： 12345678910111213141516private volatile long value;/** * Creates a new AtomicLong with the given initial value. * * @param initialValue the initial value */public AtomicLong(long initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicLong with initial value &#123;@code 0&#125;. */public AtomicLong() &#123;&#125; value是由volatile修饰的变量，在内存中可见，因此可以保证任何时刻任何线程都能拿到该变量的最新值。此处value的值，可以在AtomicLong类初始化的时候传入，也可以留空，留空则自动赋值为0。 然后我们再看下incrementAndGet()这个方法是如何实现CAS的： 12345678/** * Atomically increments by one the current value. * * @return the updated value */public final long incrementAndGet() &#123; return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;&#125; 这个方法又调用了unsafe的getAndAddLong()： 123456789public final long getAndAddLong(Object o, long offset, long delta) &#123; long v; do &#123; //拿到原来的变量值，如果没有初始化，默认为0 v = this.getLongVolatile(o, offset); &#125; while(!this.compareAndSwapLong(o, offset, v, v + delta)); return v;&#125; 再继续看compareAndSwapLong()方法： 12345678910/*** 比较obj的offset处内存位置中的值和期望的值，如果相同则更新。此更新是不可中断的。* * @param obj 需要更新的对象* @param offset obj中整型field的偏移量* @param expect 期望值* @param update 如果期望值expect与field的当前值相同，设置filed的值为这个新值* @return 如果field的值被更改返回true*/public final native boolean compareAndSwapLong(Object obj, long offset, long expect, long update); 我们知道，如果我们创建AtomicLong实例时不传入参数，则原始变量的值即为0。所以上面v = this.getLongVolatile(o, offset);拿到的值为0。而this.compareAndSwapLong()这个方法是Java本地的方法，由于Java语言无法访问到操作系统底层（如硬件等），所以Java使用native来扩展功能。这个CAS实现具体由C或C++来完成的。 大概的实现原理是：有3个操作数，内存值M，预期值E，新值U，如果M==E，则将内存值修改为U，返回true，否则返回false。如果为false，会继续拿期望的值与offset原始值做比较，知道成功为止。 这篇文章简单的模拟一个CAS实现，当然这不是真正的CAS实现，真正的CAS是CPU指令来实现的。]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中生成一个线程安全的计数器]]></title>
    <url>%2Fblog%2F2018%2F01%2F03%2Fjava-generate-counter%2F</url>
    <content type="text"><![CDATA[上一篇讲了在Java中同步访问共享的可变数据有两种方法，一个是使用sychronized关键字来同步方法或同步块，这种方法能同步数据并且还能实现访问互斥。另外一种方法是使用volatile修饰符，它仅仅实现了线程之间的交互通信。 假设我们现在需要实现一个简单的计数器，它是一个不重复且唯一的递增数值。我们使用volatile来实现看下： 12345678910111213141516171819202122232425262728293031323334public class Counter &#123; private static volatile int num = 0;//初始值 private static final int LIMIT = 50;//自增限制 private static int generateNum() &#123; return ++num; &#125; private static void incrNum() throws InterruptedException &#123; while (num &lt; LIMIT) &#123; Thread.sleep(100); if (num &lt; LIMIT) &#123;System.out.println(Thread.currentThread().getName()+": "+generateNum()); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //开5个线程跑 for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; incrNum(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 输出结果： 1234567891011121314151617181920212223242526272829Thread-0: 2Thread-4: 5Thread-3: 4Thread-2: 3Thread-1: 1Thread-0: 6Thread-1: 8Thread-2: 9Thread-4: 6Thread-3: 7Thread-0: 10Thread-2: 12Thread-4: 13Thread-1: 11Thread-3: 14Thread-4: 15Thread-3: 17Thread-1: 16Thread-0: 15Thread-2: 15…………Thread-4: 43Thread-3: 44Thread-0: 44Thread-2: 45Thread-1: 46Thread-4: 47Thread-0: 49Thread-3: 48 可以看到上述结果有很多值都是重复的，这显然不是我们想要的效果。我们的方法是确保每个调用都返回不同的值。 问题在于，增量操作符++不是原子的。它在num域中执行两项操作：首先它读取值，然后写回一个新值，相当于原来的值再加上1。如果这时候第二个线程在第一个线程读取旧值和写回新值期间读取这个域，第二个线程就会和第一个线程一起看到同一个值，并返回相同的新值。这就是安全性失败。 要修正incrNum方法的一种方法是在它的声明中添加synchronized修饰符来实现互斥。这样可以确保多个调用不会交叉存取，每个调用都会看到之前所有调用的效果，然后num的修饰符volatile就可以删除了，因为synchronized已经达到了同步的效果。像下面这样： 1234private static int num = 0;public synchronized static int generateNum() &#123; return ++num;&#125; 其它地方不需要改动，这样就可以达到想要的效果了。为了让这个方法更可靠，最好用long代替int。 还有第二种方法也可以实现相同的效果：使用类AtomicLong，它是java.util.concurrent.atomic的一部分，它比synchronized修饰符执行得更好： 123456789101112131415161718192021222324252627282930313233public class Counter &#123; private static AtomicLong serialNumber = new AtomicLong(0); private static final int LIMIT = 50; private static long generateSerialNumber() &#123; return serialNumber.incrementAndGet(); &#125; private static void incrSerialNumber() throws InterruptedException &#123; while (serialNumber.get() &lt; LIMIT) &#123; Thread.sleep(100); if (serialNumber.get() &lt; LIMIT) &#123; System.out.println(Thread.currentThread().getName()+": "+generateSerialNumber()); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; incrSerialNumber(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 输出结果： 12345678910111213141516171819202122Thread-0: 1Thread-1: 2Thread-2: 3Thread-4: 4Thread-3: 5Thread-0: 6Thread-1: 7Thread-2: 8Thread-4: 9Thread-3: 10…………Thread-3: 40Thread-0: 41Thread-3: 43Thread-4: 42Thread-2: 45Thread-1: 44Thread-0: 46Thread-3: 47Thread-4: 48Thread-2: 49Thread-1: 50 那么AtomicLong这个类的原理是什么呢？看这一篇理解Java中的AtomicLong类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中同步访问共享的可变数据]]></title>
    <url>%2Fblog%2F2017%2F12%2F31%2Fsynchronous-access-to-shared-variable-data%2F</url>
    <content type="text"><![CDATA[我们知道，线程机制允许同时进行多个活动。并发程序设计比单线程设计要困难得多，因为有更多的东西可能出错，也很难重现失败。但是我们无法避免并发，因为所做的大部分事情都需要并发，而且并发也是能否从多核的处理器中获得好的性能的一个条件。 Java中的原子操作原子操作指的是在一步之内就完成而且不能被中断。原子操作在多线程环境中是线程安全的，无需考虑同步的问题。在java中，下列操作是原子操作： all assignments of primitive types except for long and double all assignments of references all operations of java.concurrent.Atomic* classes all assignments to volatile longs and doubles 为什么long和double类型的赋值不是原子操作呢？Java中规定只有32位以下的数据类型才会有原子操作，long和double类型都是64位的，所以实际上它是把原子操作拆分成了两步： private long number = 123456789L; Java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了： private volatile long number = 123456789L; 因为volatile内部已经做了同步。 同步（Synchronized）我们知道，关键字synchronized可以保证在同一时刻只有一个线程可以执行某一个方法，或者某一个代码块。许多程序员把同步的概念仅仅理解为一种互斥的方式。即，当一个对象被一个线程修改的时候，可以阻止另一个线程观察到对象内部不一致的状态。按照这种观点，对象被创建的时候处于一致的状态，当有方法访问它的时候，它就被锁定了。这些方法观察到对象的状态，并且可能引起状态转变，即把对象从一种一致的状态转换到另一种一致的状态。正确地使用同步可以保证没有任何方法会看到对象处于不一致的状态中。 这种观点是正确的，但是它并没有说明同步的全部意义。如果没有同步，一个线程的变化就不能被其他线程看到。同步不仅可以阻止一个线程看到对象处于不一致的状态，它还可以保证进入同步方法或者同步代码块的每个线程都看到由一个锁保护之前所有的修改效果。 虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它也并不保证一个线程写入的值对于另一个线程是可见的。为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。 如果对共享的可变数据的访问不能同步，其后果将非常可怕，即使这个变量是原子可读写的。Java类库中提供了Thread.stop()方法来阻止一个线程妨碍另一个线程的任务。但是这个方法很早之前就不提倡使用，它是不安全的，使用它会导致数据遭到破坏。不要是用Thread.stop()。要阻止一个线程妨碍另一个线程，建议是先让第一个线程轮询一个boolean域，这个域一开始为false，然后通过第二个线程改为true，让第一个线程终止自己。 接下来看一下下面这个例子： 123456789101112131415161718192021222324public class StopThread &#123; private static boolean flag = true;//false终止线程，true为运行 public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int i = 0; System.out.println(Thread.currentThread().getName() + ": " + flag); while (flag) &#123; i++; &#125; System.out.println(Thread.currentThread().getName() + ": " + flag); &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); flag = false; System.out.println(Thread.currentThread().getName() + ": " + flag); &#125;&#125; 输出结果： 12Thread-0: truemain: false 可以看到线程Thread-0的flag值并没有改变并且1秒后程序还是一直在运行。 上面我们定义的flag这个boolean域的读和写操作都是原子的，程序员在访问这个域的时候不使用同步，这将导致上面的程序永远不会终止。由于没有同步，就不能保证后台线程何时看到主线程对flag值所做的改变。 接着我们修正一下，使flag域能被同步访问到： 使用同步锁，synchronized 关键字1234567891011121314151617181920212223242526272829303132public class StopThread &#123; private static boolean flag = true;//false终止线程，true为运行 private static synchronized boolean getFlag() &#123; return flag; &#125; private static synchronized void stop() &#123; flag = false; &#125; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int i = 0; System.out.println(Thread.currentThread().getName() + ": " + flag); while (getFlag()) &#123; i++; &#125; System.out.println(Thread.currentThread().getName() + ": " + flag); &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1);// flag = false; stop(); System.out.println(Thread.currentThread().getName() + ": " + flag); &#125;&#125; 输出结果： 123Thread-0: truemain: falseThread-0: false 这回的结果就是我们想要的了。这里要注意写方法stop()和读方法getFlag()都被同步了。如果两者其一没有被同步，那么同步也不会起作用。 上面的同步方法的动作即使没有同步也是原子的。也就是说，这些方法的同步只是为了通信效果，而不是为了互斥访问。这种方法性能开销会比较大，我们还有一种更好的替代方法来完成同步，它更加简洁并且性能更好。 使用修饰符，volatile 关键字1234567891011121314151617181920212223public class StopThread &#123; private static volatile boolean flag = true;//false终止线程，true为运行 public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int i = 0; System.out.println(Thread.currentThread().getName() + ": " + flag); while (flag) &#123; i++; &#125; System.out.println(Thread.currentThread().getName() + ": " + flag); &#125; &#125;).start(); TimeUnit.SECONDS.sleep(1); flag = false; System.out.println(Thread.currentThread().getName() + ": " + flag); &#125;&#125; 输出结果也是一样的： 123Thread-0: truemain: falseThread-0: false 只需要在flag前加上一个修饰符volatile，就能达到我们想要的效果。虽然volatile修饰符不执行互斥访问，但它可以保证任何一个线程在读取该域的时候都将看到最新被修改的值。 在我们的程序中，最好的办法是不共享可变的数据，要么共享不可变的数据。换句话说，将可变数据限制在单个线程中。让一个线程在短时间内修改一个数据对象，然后与其它线程共享，这是可以接受的，只同步对象引用的动作。然后其它线程没有进一步的同步也可以读取对象，只要它没有再被修改。这种对象被称作事实上不可变的。将这种对象引用从一个线程传递到其它的线程被称作安全发布。安全发布对象引用有许多种方法： 将对象保存在静态域中，作为类初始化的一部分； 将对象保存在volatile域、final域或者通过正常锁定访问域中； 将对象放到并发的集合中。 总而言之，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。未能同步共享可变数据会造成程序的活性失败和安全性失败。 Tips乐观锁与悲观锁独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 构建器]]></title>
    <url>%2Fblog%2F2017%2F12%2F30%2Fjava-constructor-builder%2F</url>
    <content type="text"><![CDATA[静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。考虑一个类的构造器具有多个参数时，就显得很不方便。 对于这样的类，应该用哪种构造器或者静态方法来编写呢？程序员一般会采用重叠构造器模式，在这种模式下，你提供一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，依次类推，最后一个构造器包含所有的可选参数。下面我们来看下这种示例： 重叠构造器模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Person &#123; private String name; private int age; private double height; private double weight; private String character; private String hobby; public Person(String name) &#123; this.name = name; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name, int age, double height) &#123; this.name = name; this.age = age; this.height = height; &#125; public Person(String name, int age, double height, double weight) &#123; this.name = name; this.age = age; this.height = height; this.weight = weight; &#125; public Person(String name, int age, double height, double weight, String character) &#123; this.name = name; this.age = age; this.height = height; this.weight = weight; this.character = character; &#125; public Person(String name, int age, double height, double weight, String character, String hobby) &#123; this.name = name; this.age = age; this.height = height; this.weight = weight; this.character = character; this.hobby = hobby; &#125;&#125; 当我们想要创建实例的时候，就利用各个不同参数的构造器，但是假如我们需要实例化一个最长参数的构造器，它就会变成这样： 1Person person = new Person("Bob", 19, 1.85, 76.5, "温和", "旅行"); 这个构造器调用通常有许多你本不想设置的参数，但还是不得不为它们传递值。重叠构造器模式虽然在参数少的情况下可行，但随着参数数目的增加，我们通常很难去编写，并且也不易阅读。如果用户想知道传参值的含义，必须仔细地数着这些参数来探个究竟。如果用户不小心颠倒了其中两个参数的顺序，编译器可能不会出错，但是在程序运行的时候也会发生致命的错误。 当我们遇到这种情况时，我们还有第二种代替的办法，即JavaBeans模式。在这种模式下调用一个无参构造器来实例化对象，然后调用setter方法来设置每个所需要的参数： JavaBeans模式12345678910111213141516171819202122232425262728293031323334public class Person &#123; private String name; private int age; private double height; private double weight; private String character; private String hobby; public Person() &#123;&#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setHeight(double height) &#123; this.height = height; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125; public void setCharacter(String character) &#123; this.character = character; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; 这种模式弥补了重叠构造器模式的不足。创建实例很容易，这样产生的代码读起来也很容易： 1234567 Person person = new Person();person.setName("Bob");person.setAge(19);person.setHeight(1.85);person.setWeight(76.5);person.setCharacter("温和");person.setHobby("旅行"); 遗憾的是，JavaBeans模式自身有着很严重的缺点。因为构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象，将会导致失败，这种失败与包含错误的代码大相径庭，因此调试起来十分困难。另外，JavaBeans模式阻止了把类做成不可变的可能，这就需要程序员付出额外的努力来确保它的线程安全。 所以，我们还有第三种替代方法，技能保证像重叠构造器那样的安全性，也能保证JavaBeans模式的可读性，这就是Builder模式。不直接生成想要的对象，而是让客户端在builer对象上调用类似于etter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变的对象。这个builder是它构建的类的静态成员类。如下所示： 构建器模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Person &#123; private final String name; private final int age; private final double height; private final double weight; private final String character; private final String hobby; public static Builder newBuilder(String name, int age) &#123; return new Builder(name, age); &#125; public static class Builder implements BuilderFactory&lt;Person&gt; &#123; //必填参数 private final String name; private final int age; //可选参数 private double height; private double weight; private String character; private String hobby; public Builder(String name, int age) &#123; this.name = name; this.age = age; &#125; public Builder setHeight(double height) &#123; this.height = height; return this; &#125; public Builder setWeight(double weight) &#123; this.weight = weight; return this; &#125; public Builder setCharacter(String character) &#123; this.character = character; return this; &#125; public Builder setHobby(String hobby) &#123; this.hobby = hobby; return this; &#125; public Person build() &#123; return new Person(this); &#125; &#125; private Person(Builder builder) &#123; this.name = builder.name; this.age = builder.age; this.height = builder.height; this.weight = builder.weight; this.character = builder.character; this.hobby = builder.hobby; &#125;&#125; 这里注意Person类是不可变的，所有的默认参数值都单独放在一个地方。builder的setter方法返回builder本身，以便可以把调用链接起来。下面看下调用代码： 123456Person person = Person.newBuilder("Bob", 19) .setHeight(1.85) .setWeight(76.5) .setCharacter("温和") .setHobby("旅行") .build(); 这样的客户端代码很容易编写和易于阅读，更为重要的是它也可以是安全的。uilder像个构造器一样，可以对其参数强加约束条件。build方法可以检验这些约束条件，将参数从builder拷贝到对象中之后，并在对象域而不是builder域中对它们进行检验，这一点很重要，。如果违反了任何的约束条件，build方法就应该抛出参数异常错误（IllegalStateException），异常的信息显示出违反了哪个约束条件。 对多个参数强加约束条件的另一种方法是，用多个setter方法对某个约束条件必须持有的所有参数进行检查。如果没有满足约束条件，setter方法就抛出IllegalArgumentException。这样一旦发现了错误，立即发现异常，而不是等着调用build方法。 设置了参数的builder生成了一个很好的抽象工厂。客户端可以将这样的一个builder传给方法，使该方法为客户端创建一个或多个对象。要使用这种方法，我们需要有个类型来表示builder，只需要一个泛型即可满足构建的所有对象的类型： 123public interface BuilderFactory&lt;T&gt; &#123; T build();&#125; 接着我们就可以声明Person的Builder类来实现BuilderFactory&lt;Person&gt;。 123456public static class Builder implements BuilderFactory&lt;Person&gt; &#123; //...fields public Person build() &#123; //todo &#125;&#125; Builder模式的确也有自身不足的地方。为了创建对象，必须先创建它的构造器。虽然创建构建器的开销在实践中可能不那么明显，但是在十分注重性能的情况下可能就是一个问题了。Builder模式比重叠构造器模式更加冗长，因此它只有在很多参数的时候才会去使用，比如4个以上的参数。 简而言之，如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识SpringAOP]]></title>
    <url>%2Fblog%2F2017%2F12%2F26%2Fspring-aop%2F</url>
    <content type="text"><![CDATA[我们知道，使用面向对象编程（OOP）有一些弊端，当需要为多个不具有继承关系的对象引入同一个公共行为时，例如日志、安全监测、权限管理等，只有在每个对象里引用公共的行为，这样程序中就产生了大量的重复代码，即不美观也不利于维护，所以就有了一个对面向对象编程的补充，即面向方面编程（AOP）。AOP所关注的方向是横向的，不同于OOP的纵向。 在Sping中，你可以使用@Aspect注解非常容易地定义一个切面。Spring采用@Aspect注解对POJO进行标注，从而定义一个包含切点信息和增强横切逻辑的切面，可以将这个切面植入到匹配的目标Bean中。下面我们来看下如何完成AOP的配置和实现。 开始配置AOP首先我们先创建一个用于拦截的Bean。假设这个类在我们实际应用中会有核心的业务，并且需要在这个类前后加入日志来跟踪调试。 123456789101112//执行项目业务逻辑的类public class TestBean &#123; public void test1(String str) &#123; System.out.println("service test1 with string: " + str); &#125; public void test2() &#123; System.out.println("service test2..."); &#125;&#125; 接着我们开始创建AOP类。这个类是负责监听所有类的test方法在执行前和执行后的时候，打印相应的日志，并且还能控制这些方法在执行前和执行后之间的一些处理（即环绕方法）。 123456789101112131415161718192021222324252627282930@Aspectpublic class AspectTest &#123; @Pointcut(value = "execution(* com.learn.aop.test*(..))") public void test() &#123;&#125; @Before(value = "test()") public void beforeTest() &#123; System.out.println("beforeTest"); &#125; @After(value = "test()") public void afterTest() &#123; System.out.println("afterTest"); &#125; @Around(value = "test()") public Object aroundTest(ProceedingJoinPoint pjp) &#123; Object obj = null; System.out.println("aroundTest1"); try &#123; obj = pjp.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("aroundTest2"); return obj; &#125;&#125; 然后我们再创建一个spring-aop.xml配置文件。123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd "&gt; &lt;!--开启AOP监听--&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean id="testBean" class="com.learn.aop.TestBean" /&gt; &lt;bean class="com.learn.aop.AspectTest" /&gt;&lt;/beans&gt; 至此，我们已经初步完成了AOP的配置。现在开始来测试看看效果。 开始测试。1234567public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("spring-aop.xml"); TestBean testBean = (TestBean) context.getBean("testBean"); testBean.test1("aop"); testBean.test2();&#125; 如果不出意外，那么会打印结果： 12345678910aroundTest1beforeTestservice test1 with string: aoparoundTest2afterTestaroundTest1beforeTestservice test2...aroundTest2afterTest Spring实现了对所有类的test方法进行扫描，我们可以很方便地在这些方法执行前后做一些日志的记录，这样就能与业务代码解耦。那么Spring究竟是如何实现AOP的？ 我们看下spring-aop.xml这个配置文件，其中&lt;aop:aspectj-autoproxy /&gt;的配置会让Spring支持带有@Aspect注解的AOP类。然后再看下@Pointcut(value = &quot;execution(* com.learn.aop.test*(..))&quot;)，@Pointcut是指哪些方法需要被执行”AOP”，里面的值是一个表达式（关于这个表达式的写法，大家可以问下度娘）。在注解下方定义一个test()方法，注意这个方法必须要定义（方法名可以随意取一个），之后定义的执行前after、执行后before以及环绕方法around都是需要依赖它的，它就相当于一个“扫描器”。接着我们就可以定义@After、@Before以及@Around方法了。只需要在你定义的方法上加上这三种注解，对应的value值是“扫描器”的方法。 这样，一个简单的AOP实现就完成了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis集群配置及原理分析]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2Fredis-cluster-config%2F</url>
    <content type="text"><![CDATA[首先创建两台虚拟机（有服务器的可以直接在服务器上搞），每台机器分别3个节点，创建出3个master和3个salve环境。 redis 采用 redis-3.2.10 版本（redis版本必须高于3.0版本，3.0版本以下不支持集群）。 两台虚拟机都是 CentOS ，一台 CentOS 7 （主IP:192.168.1.115），一台 CentOS 6.5（从IP:192.168.1.160） 。 之所以弄两个不同的操作系统版本，是为了方便大家的系统版本可能不太一样，导致进入一些坑。 先关闭防火墙12systemctl stop firewalld.service //Centos 7service iptables stop //Centos 6.5 安装Redis先在主服务器安装redis： 12345cd /usr/local/etcwget http://download.redis.io/releases/redis-3.2.10.tar.gztar -zxf redis-3.2.10.tar.gzcd redis-3.2.10make 将 redis-trib.rb 复制到 /usr/local/bin 目录下 12cd srccp redis-trib.rb /usr/local/bin/ 再创建 redis 各个节点。 首先在 192.168.31.115 机器的 /usr/local/etc/redis-3.2.10 目录下创建 redis_cluster 目录。 12mkdir redis_clustercd redis_cluster 在 redis_cluster 目录下，创建名为7000、7001、7002的目录，并将 redis.conf 拷贝到这三个目录中。 1234mkdir 7000 7001 7002cp ../redis.conf 7000/cp ../redis.conf 7001/cp ../redis.conf 7002/ 分别修改这三个配置文件，修改如下内容(每个配置文件的端口号、pidfile、cluster-config-file 都改为对应的端口号，很重要！）。 12345678910111213141516# 端口号port 7000# 默认ip为127.0.0.1 需要改为本机器ip，这里会有巨坑，如果是Centos 7版本的小伙伴请配置内网ip，Centos 6版本的小伙伴配置公网ip，否则无法启动redis。 bind 192.168.1.115# redis后台运行 daemonize yes# pidfile文件 pidfile /var/run/redis_7000.pid# 开启集群，把注释#去掉 cluster-enabled yes# 集群的配置，配置文件首次启动自动生成 cluster-config-file nodes_7000.conf# 请求超时时间，默认15秒，可自行设置cluster-node-timeout 15000# aof日志开启 有需要就开启，它会每次写操作都记录一条日志 appendonly yes 接着在另外一台机器上 192.168.1.160 重复以上相应的操作，只是把目录改为7003、7004、7005，对应的配置文件也按照这个规则修改即可。一定要细心的修改，否则就会入坑。 然后在两台服务器上启动redis服务，如下： 123456789# 主服务器redis-server redis_cluster/7000/redis.confredis-server redis_cluster/7001/redis.confredis-server redis_cluster/7002/redis.conf# 从服务器redis-server redis_cluster/7003/redis.confredis-server redis_cluster/7004/redis.confredis-server redis_cluster/7005/redis.conf 启动完后查看redis启动情况。 12345678910111213# 主服务器ps -ef | grep redisroot 24802 1 0 Sep14 ? 00:00:57 /usr/local/etc/redis-3.2.10/src/redis-server 192.168.1.115:7000 [cluster]root 24804 1 0 Sep14 ? 00:00:56 /usr/local/etc/redis-3.2.10/src/redis-server 192.168.1.115:7001 [cluster]root 24808 1 0 Sep14 ? 00:00:54 /usr/local/etc/redis-3.2.10/src/redis-server 192.168.1.115:7002 [cluster]root 27623 27605 0 10:51 pts/1 00:00:00 grep --color=auto redis# 从服务器ps -ef | grep redisroot 24802 1 0 Sep14 ? 00:00:57 /usr/local/etc/redis-3.2.10/src/redis-server 192.168.1.160:7003 [cluster]root 24804 1 0 Sep14 ? 00:00:56 /usr/local/etc/redis-3.2.10/src/redis-server 192.168.1.160:7004 [cluster]root 24808 1 0 Sep14 ? 00:00:54 /usr/local/etc/redis-3.2.10/src/redis-server 192.168.1.160:7005 [cluster]root 27623 27605 0 10:51 pts/1 00:00:00 grep --color=auto redis 如果没有启动成功，请仔细查看并修改两台服务器的redis.conf文件。 最重要的一步来了，在主服务器上创建集群，其中前三个 ip:port 为主服务器的节点，剩下三个为从服务器的节点。 Redis 官方提供了 redis-trib.rb 这个工具，就在解压目录的 src 目录中，上面我们已经将它复制到 /usr/local/bin 目录中，可以直接在命令行中使用了。使用下面这个命令即可完成安装。 12cd /usr/local/bin ./redis-trib.rb create --replicas 1 192.168.1.115:7000 192.168.1.115:7001 192.168.1.115:7002 1192.168.1.160:7003 1192.168.1.160:7004 1192.168.1.160:7005 这个工具是用 ruby 实现的，如果没有安装 ruby，需要先安装 ruby（只需要在主服务上安装）。 12yum -y install ruby ruby-devel rubygems rpm-buildgem install redis -v 3.2.1 之后再运行 redis-trib.rb 命令，会出现如下提示，输入 yes。 出现以下内容说明已经安装集群成功。 注意：如果上述命令执行后一直出现 waiting for the cluster to join... 的状态，第一，先看下redis.conf文件的bind绑定的ip是否是命令行上的ip（主ip和从ip两个）。第二，再看下防火墙是否已经关闭，如果没有，请关闭防火墙。 开始进行集群验证。 在从服务器上连接集群的7005端口的节点，连接方式为 redis-cli -h 192.168.1.160 -c -p 7005，加参数 -c 可连接到集群，因为上面 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略。 1234./redis-cli -h 192.168.1.160 -c -p 7005192.168.1.160:7005&gt; set name "hello world"OK192.168.1.160:7005&gt; 在主服务器上连接7002节点。 1234567./redis-cli -h 192.168.1.115 -c -p 7002192.168.1.115:7002&gt; keys *1) "name"192.168.1.115:7002&gt; get name-&gt; Redirected to slot [5798] located at 192.168.1.115:7002"hello world"192.168.1.115:7002&gt; 说明集群运作正常。 如果要设置集群密码，需要连接每个redis节点再依次设置如下： 1234config set masterauth passwd123config set requirepass passwd123auth passwd123config rewrite 简单说一下集群原理redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。 Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到 set 和 get 的时候，直接跳转到了7000端口的节点。 Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的 salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理和反向代理]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2Fhttp-agent%2F</url>
    <content type="text"><![CDATA[正向代理即是客户端代理，代理客户端，目的为了隐藏客户端，服务端不知道实际发起请求的客户端。 反向代理即是服务端代理，代理服务端，目的为了隐藏服务端，客户端不知道实际提供服务的服务端。 举个栗子： 正向代理：比如要访问YouTube，但是不能直接访问，只能先找个翻墙软件，通过翻墙软件才能访问YouTube，翻墙软件就是正向代理，代理我们的客户端。 反向代理：比如要访问YouTube，但是YouTube悄悄地把这个请求交给Google来做，那么YouTube就是反向代理了，代理Google的服务端。]]></content>
      <tags>
        <tag>http</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置负载均衡及http重定向https]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2Fnginx-https-proxy-pass%2F</url>
    <content type="text"><![CDATA[Nginx是一种轻量级、高性能的http和反向代理服务器。由于它的稳定性、占用资源少、配置简单，所以大多数企业都在使用它。 既然有反向代理，那么肯定也有正向代理了，什么是正向代理和反向代理呢？详见 正向代理和反向代理 Nginx的重定向配置将默认的配置文件找到如下代码并修改。 1234server &#123; listen 80; # 监听80端口 return 301 https://www.yuhechu.com$request_uri; # 跳转到https&#125; 上面的配置很简单，监听系统80端口，然后将http请求重定向到https端口上（也就是443端口）。 Nginx的负载均衡配置你可以重新定义一个.conf文件，这个文件比如是监听443端口的配置文件。 123456789101112131415161718upstream local_http &#123; # ip_hash; # 如果开启，会根据请求的ip进行分配 # 将请求转发到下面两个端口，默认权重是1。 server localhost:8080 weight=2; server localhost:8081 weight=1;&#125;server &#123; listen 443;# 监听443端口 server_name www.yuhechu.com; # 访问该端口的域名 # 证书配置... location / &#123; proxy_pass http://local_http; # 将请求代理给local_http这个变量名 add_header Access-Control-Allow-Origin *; # 允许所有ip地址进行访问 &#125; &#125; 上述配置首先先找到local_http这个变量，其中定义了两台服务地址，upstream 会按照默认方式进行负载，每个请求按权重逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。我们可以给这两台服务配置权重，上面的配置会使8080端口的访问率比8081端口高两倍。 假如开启ip_hash，那么每个请求会按访问ip的hash结果进行分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的数据类型]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2Fjava-data-type%2F</url>
    <content type="text"><![CDATA[Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。Java 数据类型分为两类，如图所示： 在 Java 的领域里，基本数据类型变量存的是数据本身（也就是值），而引用类型变量存的是保存数据的空间地址。说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。 看到这里，可能会有人疑问：那么引用数据类型变量存储的“值”放在哪里了？详见 对Java堆栈的认识。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Openssl工具生成RSA公钥和私钥]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2Fuse-openssl-rsa%2F</url>
    <content type="text"><![CDATA[首先，如果你的系统没有安装 Openssl工具，先去前往下载并安装 Openssl 工具，下载地址：https://www.openssl.org/source/。 安装好后进入它的bin目录，执行： 123456# 生成1024位的私钥openssl genrsa -out rsa_private_key.pem 1024# 如果是Java开发者，需要执行该命令将私钥转换成PKCS8格式openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem# 最后根据私钥生成对应的公钥openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 上述命令执行完成后即可在当前目录看到。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的变量作用域]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2Fjava-scope%2F</url>
    <content type="text"><![CDATA[大多数程序设计语言都提供了“作用域”（Scope）的概念。 在Java中，作用域决定了变量的“可见性”和“生存时间”。Java中的作用域是有花括号{}来决定的。 先来看一段代码： 12345678public class Scope&#123; static &#123; int a = 1; &#123;//作用域起点 int a = 2;//这里会报错，因为外部已经定义了一个a的变量 &#125;//作用域终点 &#125;&#125; 上面的例子中，由于int a = 1这行代码已经在最外部的作用域中声明a变量，所以在内部的作用域是不可以再重新声明a了，只能拿到a这个变量来进行使用，这是Java中强制规定的，而在C和C++中是允许的，因为Java的设计者认为这样会造成混淆。 再来看一个例子： 12345678public class Scope&#123; static &#123; &#123; int a = 2; &#125; int a = 1;//这样是允许的 &#125;&#125; 看到有什么不同了吗？我们把int a = 1这行代码放到了内部作用域的下方了，此时是允许的。由于int a = 2是定义在作用域里面，当超过作用域时，这块的内存空间会自动从栈中移除，并且同一块作用域的变量的“可见性”是只能在当前作用域及它的子作用域可见。由于int a = 1已经超出了该作用域，所以可以再次声明一个a变量。 再来看一个例子来理解下： 12345678910111213141516171819202122232425262728293031public class Scope&#123; private static String name = "a"; public static void func() &#123; System.out.println(name); name = "b"; &#123; String name = "c"; System.out.println(name); &#123; name = "d"; &#125; System.out.println(name); &#125; System.out.println(name); for (int i = 0; ; i++) &#123; System.out.println(i); break; &#125; int i = 1; System.out.println(i); name = "e"; System.out.println(name); &#125; public static void main(String[] args) &#123; func(); &#125;&#125; 执行结果： 1234567acdb01e Java对象不具备与基本类型数据一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外。 对象的作用域12345public class Scope&#123; void func() &#123; String str = new String(); &#125;&#125; 上面的 str 变量会在作用域外消失，但是 new String() 出来的对象是不存在栈中的，它存在堆中，并且不会随着作用域而消失。它随后会由Java垃圾回收器进行释放，垃圾回收器会查找用new所创建的所有对象，并判断其中哪些对象不再被变量引用，从而释放内存以便新的对象存储。 总结在同一作用域范围下的成员变量和局部变量是可以变量名相同的，在同一个作用域下和子作用域的局部变量则不允许变量名相同，在方法中使用变量的时候假如不指明使用成员变量还是局部变量，那么默认的就是使用成员变量，但是如果在方法中重新定义了一个和成员变量相同的局部变量，那么就会默认使用局部变量，并且在该作用域下的该变量都是使用局部变量，一旦超出该作用域，如果不指定，默认还是使用成员变量的。]]></content>
      <tags>
        <tag>scope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的值传递和引用传递]]></title>
    <url>%2Fblog%2F2017%2F12%2F24%2Fjava-value-transmit%2F</url>
    <content type="text"><![CDATA[网上查了一些资料，有的说Java里面既有引用传递，也有值传递；也有的说Java只有值传递。其实两种说法都是对的，关键是看你怎么理解它们的含义。首先要先搞明白，什么是“值”，什么是“引用”？ 一般我们认为“值”就是基本的数据类型：整数，浮点，字符和布尔。“引用”则是指向堆内存中对象的一个地址。 首先把“值”和“引用”区分开来理解下Java中我们通常是这样定义一个变量的： Type variable = ? “=” 号左边的比较好理解，Type 是一个兼容 “=” 号右边的一种类型，可以是基本类型，也可以是引用类型。variable 是我们定义的变量名。看下面的例子： 12int a = 0;User user = new User(); 上面的int a = 0;，“=”号左边的int a会告诉编译器我们定义了一个int的基本数据类型和名为a的变量，这个变量存在栈中，并且编译器也知道了这是一个基本类型的变量，然后“=”号右边的0也是直接存储在栈中并赋值给变量a。这时候我们可以理解为a的值为0。 再看User user = new User();，“=”号左边的User user告诉编译器定义我们定义了一个User的对象（引用数据类型）和名为user的变量，并且编译器知道了这是一个引用类型的变量，然后“=”号右边的new User()会在堆内存中开辟一块空间存储User这个对象，并生成一个唯一的地址值在存储在栈中，最后赋值给变量user。此时user是一个地址值，它指向堆中的User对象，user这个变量它就是堆中的User对象的引用值（不是像0这样的基本数据值直接存在栈中的）。我们把这种连接关系称为“引用”。 讲到这里，大家应该就已经明白，所谓的“引用”和“值”是什么了。简单地说，“值”就是直接在栈中取出来就能访问并且直接修改，而“引用”虽然也是存储在栈中，但显然不能直接访问，需要通过.这种语法来访问并修改堆中的对象各个属性的值。 先来看下基本类型的存取流程 123int a = 0;int b = a;a = 1; 结果：a = 1, b = 0 上面给变量a赋值为0后，又把b赋值为a，那么问题来了，a是什么？a就是0，所以b就是0。注意：b不是a！这是赋值操作。是把a的值给了b。紧接着马上给a赋值为1，这里其实是把a原来为0的值更换成了1，而b是不会受到a的影响的，b的值仍然是0。 再来看下引用类型的存取流程（可能比较难理解） 1234567891011121314151617181920public static void change(User user) &#123; //找到原来的`user`引用指向的对象，并修改name为"Bob" user.setUsername("Bob"); //将变量`user`赋值为一个新的引用，因为new User()在堆中新开辟了一个空间存储User对象，这个对象的地址值赋值给`user`变量 user = new User(); //找到新的`user`引用指向的对象，并修改name为“Jack” user.setUsername("Jack"); System.out.println(user.getUsername());&#125;//到这里结束，变量`user`消失public static void main(String[] args) &#123; //在堆中创建一个User对象，将`user`赋值为User对象的引用。 User user = new User(); //找到`user`引用指向的对象，并修改name为"Bob" user.setUsername("Mike"); System.out.println(user.getUsername()); //将`user`引用拷贝一份到change方法里面作为该方法的实参 change(user); System.out.println(user.getUsername());&#125; 上面输出的结果分别为： 123Mike Jack Bob 如果能理解上面的注释，说明你已经理解了Java中的值和引用了。 这里再补充一下其它的知识点，change方法里面重新创建的User对象跑去哪里了？在执行完最后一行代码后System.out.println(user.getUsername());，离开了这个方法块（也叫做 作用域），变量user就出栈了，它已经不存在了，而在方法中 new User()出来的这个新的对象还存在堆中，因为这个新的对象已经没有变量指向它了， 所以它会被当成垃圾，会在随后的一段时间里经过垃圾回收器的算法来自动释放掉。再来看下change方法中第一行代码user.setUsername(&quot;Bob&quot;);，这里根据传进来的“引用”修改了原来堆中的对象中的属性值，由于方法外部的user和方法内部的’user’指向堆中的同一个对象，所以会看到最后的userName的值为”Bob”，就是所谓的“引用传递”了。 最后我们把“值”和“引用”一起理解为“值”再来看下有什么不同 1234int a = 0;//a赋值为0int b = 0;//b赋值为0a = 1;//a赋值为1b = a;//b赋值为1 上面的代码很好理解，就是变量的值一直在改变，一直在进行赋值操作。 1234567891011121314public static void change(int a, int[] arr) &#123; a = 1;//a赋值为1，这里的a跟外边的a不是同一个a arr[1] = 10;//根据传入的地址值在堆中找到数组，并修改第2个元素值&#125;//到这里结束，变量a，arr消失，但堆中的arr数组还存在public static void main(String[] args) &#123; int a = 0;//a赋值为0 //在堆中创建一个数组，相当于new int[]&#123;1,2&#125; int[] arr = &#123;1, 2&#125;; System.out.println("a=" + a + ", arr=" + Arrays.toString(arr)); //拷贝一份a和arr的值，传到change方法里。a的值为0，arr的值假设为"&#123;int[2]@479&#125;" change(a, arr); System.out.println("a=" + a + ", arr=" + Arrays.toString(arr)); &#125; 打印结果： 12a=0, arr=[1, 2]a=0, arr=[1, 10] 为什么a的值没有改变？ 我是这么理解的，栈中的数据不是共享的，每块代码块之间的变量和值不会相互影响，并且超过作用域后就会消失。堆中的数据是共享的。，我们在外面传入了一个arr的“地址值”，里面的代码arr[1] = 10;是根据arr的“地址值”访问并操作了数组里面的元素值，arr这个变量并没有重新赋值，外面在访问这个“地址值”就会看到它的元素值已经被修改。假如里面的代码是arr = {5,6}，此时arr变量被重新赋值为一个新的数组了，那么相当就会在堆中创建一个新的数组，然后将arr指向这个新的“地址值”，而并没有访问原来“地址值”所对应的数组。 所以，上边也提到了，访问对象是需要通过.来进行访问和修改的，如user.name，数组元素是通过下标来访问的，如arr[0]。而“=”号是赋值操作，会重新生成一个“值”。这个值要么就是基本数据的值，要么就是用来访问对象或数组的内存值（它们都是存在栈中），所以我们可以统一理解为“值”。 说了那么多，就看各位怎么理解了，“引用”也是值，但我们习惯叫它“引用”，就是因为它是一个特殊的“值”。 Java中还有一类特殊的引用类型，就是基本类型的包装类，如Integer,Boolean,Character,Float,Long等等，它们虽然也是引用类型，但是却不能直接访问并修改它们的值，只能通过特殊手段来修改，但这样是不规范的。可以看到它们的源码的类和字段都定义了final关键字。有兴趣的小伙伴可以自己动手试试。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对Java堆栈的认识]]></title>
    <url>%2Fblog%2F2017%2F12%2F23%2Fjava-stack%2F</url>
    <content type="text"><![CDATA[当程序运行时，主要有以下几个地方可以存取数据（摘自Java编程思想）。寄存器 这是最快的存储区域，因为它位于和其他所有保存方式不同的地方:处理器内部。但是寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。 栈（先进后出） 驻留于常规RAM(随机访问存储器)区域，可通过它的“栈指针”获得处理的直接支持。栈指针若向下移，会创建新的内存;若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。但缺点是创建程序时，Java 编译器必须准确地知道栈内保存的所有数据的“长度”以及“存在时间”，缺乏灵活性。这是由于它必须生成相应的代码，以便向上和向下移动指针。 堆（队列优先，先进先出） 一种常规用途的内存池(也在RAM区域)，其中保存了Java对象。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走那些不再使用的堆中的数据。创建一个对象时，只需用new命令编写相关的代码即可。因此，用堆保存数据时会得到更大的灵活性。这种灵活性付出的代价是：在堆中分配存储空间会比较慢。 静态存储 这儿的“静态”(Static)是指“位于固定位置”(尽管也在RAM里)。程序运行期间,静 态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储空间。 常量存储 常量值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有时，在嵌入式系统中，常量本身会和其他部分分隔离开，所以在这种情况下，可以选择将其放在ROM(只读存储器)中。 非RAM存储 若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。 其中两个最主要的例子便是“流式对象”和“持久化对象”。对于流式对象，对象会变成字节流，通常会发给 另一台机器。而对于持久化对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，可以将它们恢复成普通的、基于RAM的对象。 在Java中什么时候数据会存在栈里？栈：当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间。 比如下面这段代码： 123int i = 0;char c = 'c';boolean b; Java中只要定义了一个“变量”，这个“变量”就会被分配在栈中。比如上面的 i、c、b。像int，char，boolean这种基本类型，“=”号右边的值也是存在栈中的，然后这个“变量”就赋值为右边的“值”了。这种简单的“值”如果去 new 一个出来，往往不是很高效的做法。所以在Java中，也和C，C++一样，创建一个并非是引用的“自动”变量，这些变量直接存储“值”，并放在栈中，所以更加高效。这些“变量”定义在作用域里面，超出作用域后，“变量”就消失了（即出栈）。 上图可以看到基本类型中的变量就变成了一个明确的”值“。 存放在堆里的数据堆：用于存放数组和由 new 创建的对象。在堆中分配的内存，由Java垃圾回收器来自动回收管理。在堆中生成了一个对象后，还会在栈中生成一个指向堆中的对象的一个“地址值”，此时“变量”就等于堆中生成对象的“地址值”，此后可以根据栈中的这个“地址值”找到在堆中的对象并修改对象的属性值。 比如下面这段代码： 1234int[] intArr = &#123;1,2,3,4,5&#125;;String[] strArr = new String[]&#123;"a","b","c"&#125;;User user = new User();Map map = new HashMap(); 上面讲到了变量是在栈内存中分配的，然后在程序运行到作用域外释放。而数组和对象本身在堆内存中分配，即使程序运行到作用域外，数组和对象本身占用的堆内存也不会被马上释放，但此时已经没有变量指向它们了，就变成了垃圾，不能再被使用，随后被垃圾回收器释放掉。 上图可以看到引用类型的变量就变成了指向堆内存中的一个”地址值“，本质上讲也是一个”值“。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考虑用静态方法代替构造器]]></title>
    <url>%2Fblog%2F2017%2F12%2F22%2Fstatic-replace-constructor%2F</url>
    <content type="text"><![CDATA[最近开始补点基础知识，买了本Effective Java，希望能慢慢啃完这本书。下面是书中的一些知识及我个人的一些看法。 对于类而言，为了让客户端获取它自身的一个实例，最常用的方法就是提供一个自身公有的构造器，还有一种方法，类可以提供一个公有的静态工厂方法，它只是一个返回类的实例的静态方法。下面是一个Boolean（基本类型boolean的包装类）的简单示例，这个方法将boolean基本类型值转换成了一个Boolean的对象引用: 123public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 看它的源码，发现里面定义了一个不可变的常量，也是实例化了一个对象。 1234567891011/** * The &#123;@code Boolean&#125; object corresponding to the primitive * value &#123;@code true&#125;. */ public static final Boolean TRUE = new Boolean(true); /** * The &#123;@code Boolean&#125; object corresponding to the primitive * value &#123;@code false&#125;. */ public static final Boolean FALSE = new Boolean(false); 那么通过静态工厂方法相比于通过构造器有什么好处呢？一、静态工厂方法与构造器不同的第一大优势在于，他们有名称。 如果构造器的参数本身没有确切地描述被返回的对象，那么具有适当名称的静态工厂方法会更易于阅读。例如构造器 new BigInteger(3, 10, new Random()) 返回的可能为质数（又称素数，质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数）。如果用名为 BigInteger.probablePrime(3, new Random()) 的静态方法来表示显然更清楚。 一个类只能有一个带有指定签名的构造器。我们通常知道如何避免开这一个限制：可以在构造器的参数类型，参数长度，或者是交换位置来重载。但这不是一个好主意，用户永远也记不住该用哪个构造器，如果没有对应的参考文档，往往会调用错误的构造器。 由于静态工厂方法有名称，更加灵活。当一个类需要多个带有相同签名的构造器时，就可以用它来代替构造器。 二、静态工厂方法不必每次调用它们的时候都创建一个新对象。 这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。比如上面提到的 Boolean valueOf(boolean b) 这个方法，它从来不会重新创建一个对象。这种方法类似于Flyweight模式（享元模式）。如果程序经常请求创建相同的对象，并且创建对象的代价很高，则这项技术可以极大地提升性能。 三、静态工厂方法可以返回原返回类型的任何子类型的对象。 这样我们在选择返回对象的类时就有了更大的灵活性。这种灵活性的应用是，API可以返回对象，同时又不会使对象的类变成公有的。以这种方法隐藏实现类会使API变得非常简洁。这项技术适用于基于接口的框架，因为在这种框架中，接口为静态工厂方法提供了自然返回类型。接口不能有静态方法，因此接口Type的静态工厂方法被放在一个名为Types的不可实例化的类中。 下面举个例子说明下 首先声明一个接口： 123public interface Ball &#123; void intro();&#125; 接着创建 BasketBall 类和 FootBall 类。 12345678910111213public class BasketBall implements Ball &#123; @Override public void intro() &#123; System.out.println("Play basketball"); &#125;&#125;public class FootBall implements Ball &#123; @Override public void intro() &#123; System.out.println("Play football"); &#125;&#125; 再创建一个工厂类，利用反射机制实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BallFactory &#123; /** * 第一种方法 * @param type * @return */ public static Ball getBean(String type) &#123; //声明一个引用，入栈 Ball ball = null; try &#123; //找到目标类并重新开辟一个空间存入堆中，并向上转型 ball = (Ball) Class.forName("com.learn.other.ball." + type).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return ball;//返回内存地址 &#125; /** * 第二种方法，这种方法能保证类在编译期间就能发现到底存不存在 * @param clazz * @return */ public static Ball getBean(Class&lt;?&gt; clazz) &#123; Ball ball = null; try &#123; ball = (Ball) clazz.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return ball; &#125; public static void main(String[] args) &#123; //将内存地址赋值给ball Ball ball1 = getBean("BasketBall"); Ball ball2 = getBean("FootBall"); Ball ball3 = getBean(BasketBall.class); Ball ball4 = getBean(FootBall.class); ball1.intro(); ball2.intro(); ball3.intro(); ball4.intro(); &#125; 结果如下： 1234Play basketballPlay footballPlay basketballPlay football BallFactory就利用了基类，返回了该类型的子类型。上述的类实体其实对客户端是不可见的。 静态工厂方法的缺点一、类如果不含有共有的或者受保护的构造器，就不能被子类化。 对于公有的静态工厂所返回的非公有类，也同样如此。例如，要想将 Collections Framework 中的任何方便的实现类子类化，这是不可能的。但是同样也许会因祸得福，因为它鼓励我们使用复合（组合），而不是继承。 例如下面的父类，它只能通过静态工厂方法来完成实例化对象，因为它有一个私有的构造方法，不允许被外部实例化，同时该类也不能被继承。 123456789101112131415161718192021public class Parent &#123; private static Parent parent; private Parent()&#123;&#125; public static Parent getInstance() &#123; if (parent == null) &#123; synchronized (Parent.class) &#123; if (parent == null) &#123; parent = new Parent(); &#125; &#125; &#125; return parent; &#125; @Override public String toString() &#123; return "I'm Parent"; &#125;&#125; 当我们试图去继承该类的时候，编译器就会提示报错： 但是我们可以通过复合（组合）的方式来完成实例化： 123456789public class Child &#123; public static Parent parent; public static void main(String[] args) &#123; parent = Parent.getInstance(); System.out.println(parent); &#125;&#125; 二、它们与其他的静态方法实际上没有任何区别。 它们没有像构造器那样在API文档中明确标识出来，因此对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类，这是非常困难的。你通过在类或者接口注释中关注静态工厂，并遵守标准的命名习惯，可以弥补这一劣势。 总之，我挺认同的书中的说法，平时项目中也比较喜欢用静态方法，不需要重新实例化对象，一是没必要浪费资源，二是看起来更简洁有力（其实就是懒）。至于书中所说的缺点，我感觉跟优点比起来就是小巫见大巫了。如果有静态工厂方法实际经验的，认为其有不合理之处，十分欢迎您提出宝贵的意见。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Cron表达式参数详解]]></title>
    <url>%2Fblog%2F2017%2F12%2F21%2Flinux-cron%2F</url>
    <content type="text"><![CDATA[Cron参数cron 格式: * * * * * [your command] 第1列分钟 1～59 第2列小时 0～23 第3列日 1～31 第4列月 1～12 第5列星期 0～6（0表示星期天） 第6列表示要运行的命令 几个简单的格式每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 举几个常用的例子30 8 * * * /usr/local/mysql/bin/mysqld restart 表示每天早上8点30分重启mysql。 15 4 1,11,21 * * /usr/local/mysql/bin/mysqld restart 表示每月1、11、21号早上4点15分重启mysql。 10 0 * * 0,3 [your command] 表示每周日、周三的 00:10执行一次。 0,30 18-21 * * * [your command] 表示在每天 18:00 至 21:00 之间每隔30分钟执行一次。 55 23 * * 5 [your command] 表示每星期五的 23:55 执行一次。 10 * * * * [your command] 每个整点的10分执行一次。 0 23-7/1 * * * [your command] 晚上11点到早上7点之间，每隔一小时执行一次。 */1 * * * * [your command] 每分钟执行一次。 0 0 1 1 * [your command] 一月一号的0点执行一次。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下常用的压缩，解压命令]]></title>
    <url>%2Fblog%2F2017%2F12%2F20%2Flinux-compress-command%2F</url>
    <content type="text"><![CDATA[压缩命令tar.gz 格式： tar -zcvf 自定义压缩文件名.tar.gz 被压缩文件名 zip 格式： zip -r 自定义压缩文件名.zip 被压缩文件名 如果要压缩整个文件夹，也可先进入到需要压缩文件夹的目录下，然后运行 tar -zcvf 自定义压缩文件名.tar.gz *zip -r 自定义压缩文件名.zip * 解压命令tar.gz 格式：tar -zxvf 压缩文件名.tar.gz zip 格式： unzip 压缩文件名.zip 解压缩后的文件只能放在当前的目录。 压缩文件排除某个文件或文件夹方法很多时候我们需要对某一个目录打包，而这个目录下有几十个子目录和子文件，我们需要在打包的时候排除其中一个或两个目录或几个文件。 这时候我们在用tar命令打包的时候，增加参数 –exclude 就能达到目的。 我们以myweb 为例，打包的时候我们要排除 myweb/logs 目录，命令如下 tar -zcvf myweb.tar.gz --exclude=myweb/logs myweb 如果要排除多个目录，增加 –exclude 即可，比如我们要排除logs和libs两个目录及文件readme.txt，命令如下 tar -zcvf myweb.tar.gz --exclude=myweb/logs --exclude=myweb/libs --exclude=myweb/readme.txt myweb 这里大家要注意，在我们使用tar 的–exclude 命令排除打包的时候，不能加“/”，否则还是会把logs目录以及其下的文件打包进去，例如 tar -zcvf myweb.tar.gz --exclude=myweb/logs/ --exclude=myweb/libs/ myweb （这是错误的写法） tar -zcvf myweb.tar.gz --exclude=myweb/logs --exclude=myweb/libs myweb （这是正确的写法）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中判断两个对象是否相等]]></title>
    <url>%2Fblog%2F2017%2F12%2F20%2Fequals-java-object%2F</url>
    <content type="text"><![CDATA[Java 中判断两个对象是否相等由于每次实例化一个对象时，系统会分配一块内存地址给这个对象，而系统默认是根据内存地址来检测是否是同一个对象，所以就算是同一个类里实例化出来的对象它们也不会相等。 12345678910111213141516public class Transport &#123; //名字 public String name; //运输类型 public String type; &#123; name = "交通工具"; type = "运输方式"; &#125; public void todo() &#123; System.out.println("交通工具可以载人载物"); &#125;&#125; 实例化对象后查看下内存地址，并用equals方法判断是否相等 1234567public static void main(String[] args) &#123; Transport obj = new Transport(); Transport obj1 = new Transport(); System.out.println(obj.toString()); //Transport@49476842 System.out.println(obj1.toString()); //Transport@78308db1 System.out.println(obj.equals(obj1)); // false&#125; 结果是不相等的，那么这两个对象明明是同一个对象，我们该怎么判断它们到底是不是同一个对象呢？ 方法也很简单，我们自己重写一个类方法来判断 123456public boolean equals(Object o) &#123; if (this == o) return true; //先判断o是否为本对象，如果是就肯定是同一对象了，this 指向当前的对象 if (o == null || getClass() != o.getClass()) return false; //再判断o是否为null，和o.类对象和本类对象是否一致 Transport transport = (Transport) o; //再把o对象强制转化为Transport类对象 return Objects.equals(name, transport.name) &amp;&amp; Objects.equals(type, transport.type); //查看两个对象的name和type属性值是否相等,返回结果&#125; 再来运行一遍程序,得到结果 public static void main(String[] args) { Transport obj = new Transport(); Transport obj1 = new Transport(); System.out.println(obj.toString()); //Transport@49476842 System.out.println(obj1.toString()); //Transport@78308db1 System.out.println(obj.equals(obj1)); // true }]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring事务的隔离级别]]></title>
    <url>%2Fblog%2F2017%2F12%2F20%2Fspring-transaction%2F</url>
    <content type="text"><![CDATA[Spring事务的隔离级别 ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应 ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据 ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。 ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。 脏读指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 不可重复读不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 幻觉读幻觉读: 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
</search>
